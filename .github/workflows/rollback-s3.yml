name: Rollback S3 Deployment (Reusable)

on:
  workflow_call:
    inputs:
      runner:
        type: string
        default: ubuntu-latest
      environment:
        description: "Environment name (e.g., staging, production)"
        required: true
        type: string
      aws_region:
        description: "AWS region"
        required: true
        type: string
      aws_role_arn:
        description: "AWS IAM role ARN for OIDC authentication"
        required: true
        type: string
      s3_bucket:
        description: "S3 bucket name"
        required: true
        type: string
      target_commit_hash:
        description: "Specific commit hash to rollback to (leave empty to rollback to previous release)"
        required: false
        type: string
        default: ""
      cache_control_mutable:
        description: "Cache-Control header for latest path files"
        required: false
        type: string
        default: "public, max-age=300"
      enable_cloudflare_cache_purge:
        description: "Enable Cloudflare cache purge after rollback"
        required: false
        type: boolean
        default: false
      cloudflare_zone_id:
        description: "Cloudflare Zone ID (required if enable_cloudflare_cache_purge is true)"
        required: false
        type: string
        default: ""
      s3_additional_args:
        description: "Additional arguments to pass to aws s3 sync command"
        required: false
        type: string
        default: ""
    secrets:
      CLOUDFLARE_API_TOKEN:
        description: "Cloudflare API token with cache purge permissions (required if enable_cloudflare_cache_purge is true)"
        required: false
    outputs:
      target_commit_hash:
        description: "The commit hash that was rolled back to"
        value: ${{ jobs.rollback.outputs.target_hash }}
      previous_commit_hash:
        description: "The commit hash that was rolled back from"
        value: ${{ jobs.rollback.outputs.previous_hash }}
      rollback_mode:
        description: "Rollback mode (auto or manual)"
        value: ${{ jobs.rollback.outputs.mode }}

jobs:
  rollback:
    name: Rollback ${{ inputs.environment }}
    runs-on: ${{ inputs.runner }}
    timeout-minutes: 20
    concurrency:
      group: s3-rollback-${{ inputs.environment }}-${{ inputs.s3_bucket }}
      cancel-in-progress: false
    permissions:
      id-token: write
      contents: read
    outputs:
      target_hash: ${{ steps.target.outputs.hash }}
      previous_hash: ${{ steps.current_state.outputs.current }}
      mode: ${{ steps.target.outputs.mode }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history to validate commit hashes

    - name: Configure AWS Credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.aws_role_arn }}
        aws-region: ${{ inputs.aws_region }}

    - name: Determine target commit hash
      id: target
      run: |
        BUCKET="${{ inputs.s3_bucket }}"
        MANUAL_HASH="${{ inputs.target_commit_hash }}"
        
        if [[ -n "$MANUAL_HASH" ]]; then
          echo "Manual commit hash provided: ${MANUAL_HASH}"
          
          # Validate and normalize the commit hash
          FULL_HASH=$(git rev-parse --verify "${MANUAL_HASH}" 2>/dev/null || echo "")
          
          if [[ -z "$FULL_HASH" ]]; then
            echo "âŒ Error: Invalid commit hash '${MANUAL_HASH}'"
            echo "Commit not found in git history"
            exit 1
          fi
          
          TARGET_HASH="${FULL_HASH:0:8}"
          echo "Resolved to short hash: ${TARGET_HASH}"
          echo "hash=${TARGET_HASH}" >> $GITHUB_OUTPUT
          echo "mode=manual" >> $GITHUB_OUTPUT
        else
          echo "No manual hash provided, rolling back to previous release..."
          
          # Get current commit hash from S3
          CURRENT_HASH=$(aws s3api head-object \
            --bucket "${BUCKET}" \
            --key "latest/index.html" \
            --query 'Metadata."commit-hash-short"' \
            --output text 2>/dev/null || echo "")
          
          if [[ -z "$CURRENT_HASH" || "$CURRENT_HASH" == "None" ]]; then
            echo "âŒ Error: Could not determine current commit hash from S3 metadata"
            exit 1
          fi
          
          echo "Current commit: ${CURRENT_HASH}"
          
          # Get previous commit hash from metadata
          PREVIOUS_HASH=$(aws s3api head-object \
            --bucket "${BUCKET}" \
            --key "latest/index.html" \
            --query 'Metadata."prev-commit-hash-short"' \
            --output text 2>/dev/null || echo "")
          
          if [[ -z "$PREVIOUS_HASH" || "$PREVIOUS_HASH" == "None" ]]; then
            echo "âŒ Error: No previous commit hash found in metadata"
            echo "This might be the first deployment, or the deployment was made before prev-commit-hash-short tracking was added"
            echo ""
            echo "Available versions in S3:"
            aws s3 ls "s3://${BUCKET}/" | grep "PRE" | awk '{print $2}' | sed 's/\///' | grep -E '^[a-f0-9]{8}$' || echo "No versions found"
            exit 1
          fi
          
          echo "Previous commit: ${PREVIOUS_HASH}"
          TARGET_HASH="$PREVIOUS_HASH"
          echo "hash=${TARGET_HASH}" >> $GITHUB_OUTPUT
          echo "current=${CURRENT_HASH}" >> $GITHUB_OUTPUT
          echo "mode=auto" >> $GITHUB_OUTPUT
        fi

    - name: Verify target commit exists in S3
      run: |
        BUCKET="${{ inputs.s3_bucket }}"
        TARGET_HASH="${{ steps.target.outputs.hash }}"
        
        echo "Checking if commit ${TARGET_HASH} exists in bucket ${BUCKET}..."
        
        if aws s3 ls "s3://${BUCKET}/${TARGET_HASH}/" | grep -q .; then
          echo "âœ… Commit ${TARGET_HASH} found in S3"
        else
          echo "âŒ Commit ${TARGET_HASH} not found in S3"
          echo "This commit was never deployed. Available versions:"
          aws s3 ls "s3://${BUCKET}/" | grep "PRE" | awk '{print $2}' | sed 's/\///' | grep -E '^[a-f0-9]{8}$' || echo "No versions found"
          exit 1
        fi

    - name: Get current state for metadata
      id: current_state
      run: |
        BUCKET="${{ inputs.s3_bucket }}"
        
        # Get current commit hash (might be different from target if manual rollback)
        CURRENT_HASH=$(aws s3api head-object \
          --bucket "${BUCKET}" \
          --key "latest/index.html" \
          --query 'Metadata."commit-hash-short"' \
          --output text 2>/dev/null || echo "")
        
        if [[ -n "$CURRENT_HASH" && "$CURRENT_HASH" != "None" ]]; then
          echo "current=${CURRENT_HASH}" >> $GITHUB_OUTPUT
        else
          echo "current=unknown" >> $GITHUB_OUTPUT
        fi

    - name: Download target commit files
      run: |
        BUCKET="${{ inputs.s3_bucket }}"
        TARGET_HASH="${{ steps.target.outputs.hash }}"
        
        echo "Downloading files from commit ${TARGET_HASH}..."
        mkdir -p rollback-temp
        aws s3 sync "s3://${BUCKET}/${TARGET_HASH}/" rollback-temp/ \
          ${{ inputs.s3_additional_args }}
        
        FILE_COUNT=$(find rollback-temp -type f | wc -l)
        echo "Downloaded ${FILE_COUNT} files"

    - name: Rollback latest path
      run: |
        BUCKET="${{ inputs.s3_bucket }}"
        TARGET_HASH="${{ steps.target.outputs.hash }}"
        CURRENT_HASH="${{ steps.current_state.outputs.current }}"
        TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
        
        echo "Rolling back ${BUCKET}/latest/ to commit ${TARGET_HASH}..."
        
        # Build metadata
        METADATA="deployed-at=${TIMESTAMP},commit-hash-short=${TARGET_HASH},environment=${{ inputs.environment }}"
        
        # Add prev-commit-hash-short (the current one we're rolling back from)
        if [[ -n "$CURRENT_HASH" && "$CURRENT_HASH" != "unknown" ]]; then
          METADATA="${METADATA},prev-commit-hash-short=${CURRENT_HASH}"
        fi
        
        # Add rollback tracking
        METADATA="${METADATA},rolled-back-from=${CURRENT_HASH},rollback-by=${{ github.actor }}"
        
        # Upload to latest path (same logic as deploy)
        aws s3 sync rollback-temp/ "s3://${BUCKET}/latest/" \
          --cache-control "${{ inputs.cache_control_mutable }}" \
          --metadata "${METADATA}" \
          --metadata-directive REPLACE \
          --delete \
          ${{ inputs.s3_additional_args }}
        
        echo "âœ… Rollback complete!"
        echo "Latest path now points to commit: ${TARGET_HASH}"

    - name: Purge Cloudflare cache
      if: inputs.enable_cloudflare_cache_purge == true
      uses: carlssonk/cicd-toolkit/.github/actions/purge-cloudflare-cache@main
      with:
        cloudflare_zone_id: ${{ inputs.cloudflare_zone_id }}
        cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}

    - name: Rollback Summary
      run: |
        MODE="${{ steps.target.outputs.mode }}"
        TARGET="${{ steps.target.outputs.hash }}"
        CURRENT="${{ steps.current_state.outputs.current }}"
        
        echo "## ðŸ”„ Rollback Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
        
        if [[ "$MODE" == "manual" ]]; then
          echo "- **Rollback type**: Manual (specific commit)" >> $GITHUB_STEP_SUMMARY
          echo "- **Target commit**: \`${TARGET}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Rolled back from**: \`${CURRENT}\`" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Rollback type**: Automatic (previous release)" >> $GITHUB_STEP_SUMMARY
          echo "- **Rolled back from**: \`${CURRENT}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Rolled back to**: \`${TARGET}\`" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "- **Performed by**: @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "The \`latest\` path has been updated to serve commit \`${TARGET}\`." >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ inputs.enable_cloudflare_cache_purge }}" = "true" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Cloudflare" >> $GITHUB_STEP_SUMMARY
          echo "- Cache purged for zone \`${{ inputs.cloudflare_zone_id }}\`" >> $GITHUB_STEP_SUMMARY
        fi

